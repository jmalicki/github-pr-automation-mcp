{
  "data": {
    "node": {
      "author": {
        "login": "coderabbitai"
      },
      "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Surface ‚Äúdestructive‚Äù status and safety warnings for `cleanup_worktree`.**\n\nDocs currently omit the destructive badge and safety notes that tests expect and users need.\n\n\n\nApply:\n\n```diff\n-            doc.push_str(&format!(\"### `{}`\\n\\n\", name));\n+            let header = if name == \"cleanup_worktree\" {\n+                format!(\"### `{}` ‚ö†Ô∏è **DESTRUCTIVE**\\n\\n\", name)\n+            } else {\n+                format!(\"### `{}`\\n\\n\", name)\n+            };\n+            doc.push_str(&header);\n```\n\nAnd add warnings inside the `cleanup_worktree` arm:\n\n```diff\n                 \"cleanup_worktree\" => {\n                     doc.push_str(\"**Parameters:**\\n\");\n                     doc.push_str(\"- `worktree_path` (string, required): Path to the worktree to clean up\\n\");\n                     doc.push_str(\"- `delete_branch` (boolean, optional): Whether to delete the branch (default: false)\\n\");\n                     doc.push_str(\"- `force` (boolean, optional): Whether to force cleanup even if there are uncommitted changes (default: false)\\n\");\n+                    doc.push_str(\"\\n‚ö†Ô∏è Warning:\\n\");\n+                    doc.push_str(\"- Kill running agent processes\\n\");\n+                    doc.push_str(\"- Remove the worktree directory\\n\");\n+                    doc.push_str(\"- Cannot be undone\\n\");\n                 }\n```\n\n\nAlso applies to: 37-48\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
      "createdAt": "2025-10-28T05:01:02Z",
      "databaseId": 2467915784,
      "diffHunk": "@@ -17,188 +13,104 @@ impl DocGenerator {\n         \n         doc.push_str(\"## MCP Tools\\n\\n\");\n         \n-        let tools = SubagentWorktreeServer::get_tools();\n-        for tool in &tools {\n-            doc.push_str(&Self::generate_tool_documentation(tool));\n-            doc.push_str(\"\\n\");\n-        }\n-        \n-        doc\n-    }\n-\n-    /// Generate documentation for a single MCP tool\n-    fn generate_tool_documentation(tool: &Tool) -> String {\n-        let mut doc = String::new();\n+        // Define the tools manually since we're using rmcp macros now\n+        let tools = vec![\n+            (\"spawn_subagent\", \"Spawn a new subagent with a git worktree for isolated development\"),\n+            (\"cleanup_worktree\", \"Clean up a worktree and optionally delete the branch (destructive)\"),\n+            (\"list_worktrees\", \"List all git worktrees and their associated agents\"),\n+        ];\n         \n-        // Tool header with destructive warning if applicable\n-        let is_destructive = tool.name == \"cleanup_worktree\";\n-        if is_destructive {\n-            doc.push_str(&format!(\"### `{}` ‚ö†Ô∏è **DESTRUCTIVE**\\n\\n\", tool.name));\n-        } else {\n-            doc.push_str(&format!(\"### `{}`\\n\\n\", tool.name));\n-        }\n-\n-        // Description\n-        if let Some(description) = &tool.description {\n+        for (name, description) in tools {\n+            doc.push_str(&format!(\"### `{}`\\n\\n\", name));\n             doc.push_str(&format!(\"{}\\n\\n\", description));\n-        }\n-\n-        // Parameters from JSON schema\n-        if let mcp::types::ToolInputSchema::JsonSchema(schema) = &tool.input_schema {\n-            if let Some(properties) = schema.get(\"properties\").and_then(|p| p.as_object()) {\n-                if !properties.is_empty() {\n+            \n+            // Add parameter information based on tool name\n+            match name {\n+                \"spawn_subagent\" => {\n                     doc.push_str(\"**Parameters:**\\n\");\n-                    \n-                    let required_fields = schema.get(\"required\")\n-                        .and_then(|r| r.as_array())\n-                        .map(|arr| arr.iter().filter_map(|v| v.as_str()).collect::<std::collections::HashSet<_>>())\n-                        .unwrap_or_default();\n-\n-                    for (name, prop) in properties {\n-                        if let Some(prop_obj) = prop.as_object() {\n-                            let description = prop_obj.get(\"description\")\n-                                .and_then(|d| d.as_str())\n-                                .unwrap_or(\"No description available\");\n-                            \n-                            let param_type = prop_obj.get(\"type\")\n-                                .and_then(|t| t.as_str())\n-                                .unwrap_or(\"unknown\");\n-                            \n-                            let required = required_fields.contains(name.as_str());\n-                            \n-                            doc.push_str(&format!(\n-                                \"- `{}`: {} ({}, {})\\n\",\n-                                name,\n-                                description,\n-                                param_type,\n-                                if required { \"required\" } else { \"optional\" }\n-                            ));\n-                        }\n-                    }\n-                    doc.push_str(\"\\n\");\n+                    doc.push_str(\"- `branch_name` (string, required): Name of the branch to create for the subagent\\n\");\n+                    doc.push_str(\"- `prompt` (string, required): Initial prompt to give to the subagent\\n\");\n+                    doc.push_str(\"- `worktree_dir` (string, optional): Optional directory name for the worktree (defaults to branch name)\\n\");\n+                    doc.push_str(\"- `agent_type` (string, optional): Agent type to spawn (defaults to \\\"cursor-agent\\\")\\n\");\n+                    doc.push_str(\"- `agent_options` (object, optional): Additional options for the agent\\n\");\n                 }\n+                \"cleanup_worktree\" => {\n+                    doc.push_str(\"**Parameters:**\\n\");\n+                    doc.push_str(\"- `worktree_path` (string, required): Path to the worktree to clean up\\n\");\n+                    doc.push_str(\"- `delete_branch` (boolean, optional): Whether to delete the branch (default: false)\\n\");\n+                    doc.push_str(\"- `force` (boolean, optional): Whether to force cleanup even if there are uncommitted changes (default: false)\\n\");\n+                }\n+                \"list_worktrees\" => {\n+                    doc.push_str(\"**Parameters:**\\n\");\n+                    doc.push_str(\"- `include_agents` (boolean, optional): Whether to include agent information (default: true)\\n\");\n+                    doc.push_str(\"- `only_our_agents` (boolean, optional): Only show agents spawned by our system (default: true)\\n\");\n+                    doc.push_str(\"- `only_waiting_agents` (boolean, optional): Only show agents waiting for input (default: false)\\n\");\n+                }\n+                _ => {}\n             }\n+            \n+            doc.push_str(\"\\n\");\n         }",
      "id": "PRRC_kwDOQKdW-c6TGWgI",
      "originalPosition": 113,
      "path": "src/doc_generator.rs",
      "pullRequestReview": {
        "databaseId": 3386631280,
        "id": "PRR_kwDOQKdW-c7J2-Rw"
      },
      "updatedAt": "2025-10-28T05:01:04Z"
    }
  }
}

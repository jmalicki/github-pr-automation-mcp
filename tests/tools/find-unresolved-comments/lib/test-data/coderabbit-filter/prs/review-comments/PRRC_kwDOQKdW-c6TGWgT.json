{
  "data": {
    "node": {
      "author": {
        "login": "coderabbitai"
      },
      "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Implement branch deletion.**\n\n`remove_branch` is a stub. When users set `delete_branch: true` in `CleanupConfig`, they expect the branch to be deleted, but currently only a log message is produced.\n\nImplement actual branch deletion using Git commands (e.g., `git branch -D <branch_name>`), likely by adding a method to `GitWorktreeManager`.\n\n\n\n\nDo you want me to generate the implementation for branch deletion in `GitWorktreeManager`?\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/lib.rs around lines 173‚Äì177 the async fn remove_branch is a stub that\nonly logs the branch name; implement actual branch deletion by adding a method\non GitWorktreeManager (e.g., delete_branch or remove_branch) that runs the git\nbranch -D <branch_name> command in the repo/worktree directory (using\nstd::process::Command or your existing git helper) and returns a Result<(),\nError>. Update this async remove_branch to call that GitWorktreeManager method,\nawait or map its result into the function Result, log success or error, and\npropagate failures (converting command failures into the crate's Error type) so\ndelete_branch: true truly removes the branch.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
      "createdAt": "2025-10-28T05:01:03Z",
      "databaseId": 2467915795,
      "diffHunk": "@@ -13,12 +13,221 @@ pub mod doc_generator;\n pub use agent_monitor::{AgentMonitor, AgentMonitorConfig, AgentProcessInfo, AgentSummary};\n pub use git_operations::{GitWorktreeManager, WorktreeInfo};\n pub use subagent_spawner::{AgentSpawner, AgentOptions, AgentInfo, SubagentSpawner, CursorCliAgent};\n-pub use doc_generator::{DocGenerator, run_doc_generator};\n+pub use doc_generator::DocGenerator;\n \n-/// Main server configuration and implementation\n-pub mod server {\n-    pub use crate::main::{SubagentWorktreeServer, SubagentConfig, CleanupConfig};\n+// MCP Server implementation\n+use anyhow::Result;\n+use rmcp::tool_router;\n+use rmcp::tool;\n+use rmcp::handler::server::wrapper::Parameters;\n+use rmcp::handler::server::tool::ToolRouter;\n+use schemars::JsonSchema;\n+use serde::{Deserialize, Serialize};\n+use std::path::PathBuf;\n+use tracing::info;\n+\n+/// Configuration for spawning a subagent\n+#[derive(Debug, Serialize, Deserialize, JsonSchema)]\n+pub struct SubagentConfig {\n+    /// Name of the branch to create for the subagent\n+    pub branch_name: String,\n+    /// Initial prompt to give to the subagent\n+    pub prompt: String,\n+    /// Optional directory name for the worktree (defaults to branch name)\n+    pub worktree_dir: Option<String>,\n+    /// Agent type to spawn (defaults to \"cursor-agent\")\n+    pub agent_type: Option<String>,\n+    /// Additional options for the agent\n+    pub agent_options: Option<AgentOptions>,\n+}\n+\n+/// Configuration for cleaning up a worktree\n+#[derive(Debug, Serialize, Deserialize, JsonSchema)]\n+pub struct CleanupConfig {\n+    /// Path to the worktree to clean up\n+    pub worktree_path: String,\n+    /// Whether to delete the branch (default: false)\n+    pub delete_branch: Option<bool>,\n+    /// Whether to force cleanup even if there are uncommitted changes (default: false)\n+    pub force: Option<bool>,\n+}\n+\n+/// Configuration for listing worktrees\n+#[derive(Debug, Serialize, Deserialize, JsonSchema)]\n+pub struct ListWorktreesConfig {\n+    /// Whether to include agent information (default: true)\n+    pub include_agents: Option<bool>,\n+    /// Only show agents spawned by our system (default: true)\n+    pub only_our_agents: Option<bool>,\n+    /// Only show agents waiting for input (default: false)\n+    pub only_waiting_agents: Option<bool>,\n+}\n+\n+/// Main MCP server for subagent worktree management\n+pub struct SubagentWorktreeServer {\n+    git_manager: GitWorktreeManager,\n+    spawner: SubagentSpawner,\n+    tool_router: ToolRouter<Self>,\n }\n \n-// Include the main module (which contains the server implementation)\n-mod main;\n+impl SubagentWorktreeServer {\n+    pub fn new(repo_path: PathBuf) -> Result<Self> {\n+        let git_manager = GitWorktreeManager::new(repo_path)?;\n+        let spawner = SubagentSpawner::new()?;\n+        \n+        Ok(Self {\n+            git_manager,\n+            spawner,\n+            tool_router: Self::tool_router(),\n+        })\n+    }\n+\n+    async fn handle_spawn_subagent(&self, config: SubagentConfig) -> Result<String> {\n+        let worktree_dir = config.worktree_dir.unwrap_or_else(|| config.branch_name.clone());\n+        let agent_type = config.agent_type.unwrap_or_else(|| \"cursor-agent\".to_string());\n+        \n+        info!(\"Spawning subagent: branch={}, worktree={}, agent={}\", \n+              config.branch_name, worktree_dir, agent_type);\n+\n+        // Create the worktree\n+        let worktree_path = self.git_manager.create_worktree(\n+            &config.branch_name,\n+            None, // No base branch specified\n+            Some(&worktree_dir),\n+        ).await?;\n+\n+        // Spawn the agent\n+        let options = config.agent_options.unwrap_or_default();\n+        self.spawner.spawn_agent(\n+            &agent_type,\n+            &worktree_path,\n+            &config.prompt,\n+            &options,\n+        ).await?;\n+\n+        Ok(format!(\"Successfully spawned {} subagent in worktree: {}\", \n+                   agent_type, worktree_path.display()))\n+    }\n+\n+    async fn handle_cleanup_worktree(&self, config: CleanupConfig) -> Result<String> {\n+        let worktree_path = PathBuf::from(&config.worktree_path);\n+        let delete_branch = config.delete_branch.unwrap_or(false);\n+        let force = config.force.unwrap_or(false);\n+\n+        info!(\"Cleaning up worktree: {}, delete_branch={}, force={}\", \n+              worktree_path.display(), delete_branch, force);\n+\n+        // Kill any agents running in this worktree\n+        self.kill_agents_in_worktree(&worktree_path).await?;\n+\n+        // Remove the worktree\n+        self.git_manager.remove_worktree(&worktree_path).await?;\n+\n+        let mut result = format!(\"Successfully cleaned up worktree: {}\", worktree_path.display());\n+\n+        // Optionally delete the branch\n+        if delete_branch {\n+            if let Some(branch_name) = worktree_path.file_name()\n+                .and_then(|name| name.to_str()) {\n+                self.remove_branch(branch_name).await?;\n+                result.push_str(&format!(\" and deleted branch: {}\", branch_name));\n+            }\n+        }\n+\n+        Ok(result)\n+    }\n+\n+    async fn handle_list_worktrees(&self, config: ListWorktreesConfig) -> Result<String> {\n+        let include_agents = config.include_agents.unwrap_or(true);\n+        let only_our_agents = config.only_our_agents.unwrap_or(true);\n+        let only_waiting_agents = config.only_waiting_agents.unwrap_or(false);\n+\n+        info!(\"Listing worktrees: include_agents={}, only_our_agents={}, only_waiting_agents={}\", \n+              include_agents, only_our_agents, only_waiting_agents);\n+\n+        let worktrees = self.git_manager.list_worktrees().await?;\n+        \n+        if !include_agents {\n+            let worktree_info: Vec<String> = worktrees.iter()\n+                .map(|wt| format!(\"- {} (branch: {})\", wt.path.display(), wt.branch.as_deref().unwrap_or(\"unknown\")))\n+                .collect();\n+            return Ok(worktree_info.join(\"\\n\"));\n+        }\n+\n+        // TODO: Implement agent monitoring integration\n+        // For now, just return worktree information\n+        let worktree_info: Vec<String> = worktrees.iter()\n+            .map(|wt| format!(\"- {} (branch: {}) - No agent info available\", wt.path.display(), wt.branch.as_deref().unwrap_or(\"unknown\")))\n+            .collect();\n+        \n+        Ok(worktree_info.join(\"\\n\"))\n+    }\n+\n+    async fn kill_agents_in_worktree(&self, worktree_path: &PathBuf) -> Result<()> {\n+        // TODO: Implement agent process killing\n+        // This would use the agent monitor to find and kill processes\n+        info!(\"Killing agents in worktree: {}\", worktree_path.display());\n+        Ok(())\n+    }\n+\n+    async fn remove_branch(&self, branch_name: &str) -> Result<()> {\n+        // TODO: Implement branch deletion\n+        info!(\"Removing branch: {}\", branch_name);\n+        Ok(())\n+    }",
      "id": "PRRC_kwDOQKdW-c6TGWgT",
      "originalPosition": 171,
      "path": "src/lib.rs",
      "pullRequestReview": {
        "databaseId": 3386631280,
        "id": "PRR_kwDOQKdW-c7J2-Rw"
      },
      "updatedAt": "2025-10-28T05:01:04Z"
    }
  }
}
